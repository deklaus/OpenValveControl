/** @file     main.c
 *  @brief    Main program for Project "ValveControl"
 *  @par  (c) 2023-2024 Klaus Deutschkämer
 *  License: EUROPEAN UNION PUBLIC LICENCE v. 1.2 \n
 *  see https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 * 
 *  \b IDE:      <c> MPLAB X IDE v5.45 &rarr; </c> 
 *  \b Packs:    <c> PIC18F-Q_DFP (v1.8.154) </c> \n
 *  \b Device:   <c> Microchip \b PIC18F16Q41 </c> \n
 *  \b Compiler: <c> XC8 (v2.32) FREE Version, C-Standard: C99, 
 *                   Optimization Level: 2 </c> \n
 *  \b Linker:   <c> XC8 Global Options | XC8 Linker | Options:
 *                   - Runtime | Initialize Data: checked
 *                   - Memory Model | Rom Range:default,-0-7FF
 *  @todo
 *  - Actually all reference flags are initialized, so that move commands are
 *    allowed prior reference runs are performed. To be deleted (or not).
 *  - After HOME run, sometimes position is not reset to 0.
 *  - Implement timeout on all position jobs. Within IDLE, proper 
 *    handling of parallel jobs via UI must be solved (priority and
 *    selected valve must not accidentally be swapped.
 *  - Define unique error numbering (enums) across bootloader and application.
 *  - When battery supply is desirable, sleep mode must be used with
 *    wakeup on messages from ESP.
 */

/* Change Log:
 * 2024-02-13 v0.8.1
 * - Status? now returns g_vbemf_sum[g_vz] instead of g_vbemf_sum[1].
 * 2024-02-13 v0.8
 * - Added logdata bemf_log[1024] - recording V_BEMF, and curr_log[1024] -
 *   recording the motor current of the last MOVE or HOME travel.
 * - Added new WebUI command "/logdata?" to transmit logdata to ESP.
 * - Added experimental g_vbemf_sum (integral of speed x dt ~ distance?)
 * 2024-02-13 v0.7.2
 * - 1 ms delay() in ina219_read() replaced by negative value to indicate error.
 * 2024-01-29 v0.7.1
 * - Error corrected in bootloader when copying code to bufferRam.
 * 2024-01-20 v0.7
 * - PWM is now generated by the 16 bit PWM module (CCP pwm was hogging TMR2).
 *   PWM1 slice1 P1out is used to drive the H-bridges, its right edge is used to
 *   read VBEMF in the PWM1_isr.
 *   slice1 P2out (right edge, ca. 2 ms after H-bridge ON) now invokes the 
 *   PWM_isr to read the motor current. This eliminates the annoying 2 ms delay 
 *   within the IOC_ISR, which was causing missed ESP commands).
 *  2023-12-03 V0.6.1
 *  - Added 2 minutes timeout when homeing.
 * 2023-11-23 v0.6
 * - Added: Bootloader
 * - Version number raised to current ESP version
 * 2023-10-30 V0.2 
 * - Some motor directions fixed.
 * - doxygen comments updated.
 * 2023-10-17 V0.1
 * - Initial issue
 */

#include <xc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pic18f16q41.h>

#include "main.h"
#include "adc.h"
#include "daq.h"
#include "i2c.h"
#include "init.h"

// *** data type, constant and macro definitions

/// States of the main loop (state machine)
enum states {
    state_idle = 0, //!< default state (no commands pending)
    state_home,     //!< homing of selected axis (close direction)
    state_move,     //!< move selected axis
};

// *** global variables
const char  *g_version = "v0.8.1";    ///< Software version


uint16_t    FVRA2X;     ///< DIA: @ADC FVR1 voltage for 2x setting (in mV)
uint16_t    FVRC2X;     ///< DIA: @CMP/DAC FVR2 voltage for 2x setting (in mV)
uint16_t    VDD;        ///< VDD [0.01 V] (battery voltage)
int16_t     temp_indi;  ///< temp. read from temperature indicator (future option)
float       temp_ds;    ///< temperature read from DS18B20 (future option)

static void sleep_config(void);
static void timer1_config(void);

volatile uint8_t    g_rx232_buf[48];    ///< RS232 RX buffer (> sizeof(S1-record)!
volatile uint8_t    g_rx232_count;      ///< counts buffered RX chars
volatile uint8_t    g_tx232_buf[48];    ///< RS232 TX buffer

volatile uint8_t    g_rs232_request;    ///< new RS232 request received from ESP 
volatile uint8_t    g_rs232_response;   ///< response pending (not yet sent)

volatile STATUSflags_t  g_STATUSflags;   ///< status feedback for ESP
volatile ERRORflags_t   g_ERRORflags;    ///< error flags

volatile uint16_t   g_timer_ms;     ///< incremented every 1 ms by TMR0 isr
volatile bool       g_tovfl_ms;     ///< g_timer_ms > 0xFFFF

volatile uint8_t    g_vz;                    ///< selected vz  {(0), 1 - NUM_VZ}
volatile uint8_t    g_setpos[NUM_VZ + 1];    ///< set position {(0), 1 - NUM_VZ}
volatile uint8_t    g_position[NUM_VZ + 1];  ///< position     {0 .. 100%}
volatile int16_t    g_zcd[NUM_VZ + 1];       ///< ticks by zcd {0 .. 1000 .. }
volatile int16_t    g_mAx10_max[NUM_VZ + 1]; ///< max current  {-3276.7 .. 3276.7} mA
volatile int32_t    g_vbemf_sum[NUM_VZ + 1]; ///< sum of g_vbemf

volatile int16_t    g_mAx10;        ///< actual motor current / 0.1 mA
volatile uint16_t   g_vbemf;        ///< actual Back EMK (ADC raw)
volatile int8_t     g_dir;          ///< motor direction [-1, 0, +1]

volatile uint8_t    g_zerocount;    ///< counts pwm cycles since last zero cross

/** @note Data logger indices are reset on every MOVE or HOME command.
 * Data logger buffers are filled up with zeros in idle. */
volatile uint8_t    g_vbemf_log[LOGSIZE];   ///< data logger: g_vbemf >> 4
volatile uint8_t    g_curr_log[LOGSIZE];    ///< data logger: g_mAx10 >> 2
volatile uint16_t   g_ns_bemf;
volatile uint16_t   g_ns_curr;


// *** static variables
static  uint8_t     main_state = 0;     ///< main: state machine
static  uint16_t    last_tick;          ///< timer value at last PWM start
static  uint8_t     n_overcurr;         ///< counts overcurrent events
static  uint16_t    ix_logdata = 0;     ///< index to transmit logdata to ESP

// *** private function prototypes
static void     cmd_interpreter (void);
static bool     over_current (uint8_t vz);
static void     set_pwm (uint8_t vz, int8_t dir);


// *** public function bodies

/** @brief This function outputs one char to the EUSART and is also the helper 
 *  function for the printf() function. \n
 *  When the TXIF bit is not set within approx. 1 ms, the function returns
 *  and data gets lost.
 */
void putch (char data)
{
    for (uint8_t timeout = 20; (0 == PIR4bits.U1TXIF) && (timeout > 0); --timeout)
    {
        __delay_us(50);                   
    }    
    if (PIR4bits.U1TXIF)
    {
        U1TXB = data;   // send data
    }    
} // putch


/** @brief This is the Main program
 */
void main(void)
{
    int16_t     ival16;
    int8_t      diff;
    uint16_t    t_home_ms, t_home_s;
    uint8_t     motor = 0;
       
    interrupt_GlobalHighDisable();    
    
    /** - Initialize the device
     */
    init_system();    

#ifdef TEST_PWM
    // test direct FET
    set_pwm(1, -1);  // RA5 = PWM output
    while (1) { };
#endif
    
    
#ifdef TEST_DACOUT_A2
    // TEST: Monitor output via DAC1 -> RA2
    LATAbits.LATA2 = 1;    // TEST (for DAC: A2 = HiZ)
    ODCONAbits.ODCA2 = 1;
    TRISAbits.TRISA2 = 1;
    ANSELAbits.ANSELA2 = 1;    
    DAC1DATL = 0;       // DAC voltage = 0 V
    DAC1CON = 0xA0;     // DACxEN = 1, Vout@RA2, Vref+ = VDD, Vref- = GND
#endif
    
#ifdef TEST_SETREF
    //g_STATUSflags.ref1 = 1;     // set some ref positions
    g_STATUSflags.ref = 0x0f;   // set all  ref positions
#endif
    
    while (1)   // This is the main loop
    {   
        /** Main loop:
         *  - Measure VDD [0.01 V] (optional battery check) */
        VDD = daq_vdd();        

        /** - Check for requests from ESP via RS232
		 */        
        if (g_rs232_request)    // command received from ESP (flag gets set by ISR)?
        {
            cmd_interpreter();  // sets main_state according to command
        }
        
        switch(main_state) 
        {
            /** - MOVE command
			 */
            case state_move:
                
                diff = (int8_t) (g_setpos[g_vz] - g_position[g_vz]);
                if      (diff > 0) g_dir = +1;
                else if (diff < 0) g_dir = -1;
                else  // diff == 0 
                {
                    g_dir = 0;
                    g_STATUSflags.move = 0;     // position reached
                    g_STATUSflags.vz = 0;       // deselect drive

#ifdef TEST_AUTO_RETURN
                    // TEST: auto return to zero position
                    if (0 == g_setpos[g_vz])
                    {
                        main_state = state_idle;
                    }
                    else
                    {
                        set_pwm(g_vz, g_dir);   // stop pwm
                        __delay_ms(100);       // stop motor before reverse dir
                        g_setpos[g_vz] = 0;
                        g_vbemf = 0;
                        g_dir = -1;
                    }
#else
                    main_state = state_idle;
#endif                    
                }

                if (over_current(g_vz))     // check for over current
                {                           // overrides g_dir if true
                    main_state = state_idle;
                    g_STATUSflags.move = 0;
                }

                // set PWM outputs according g_vz and moving direction
                set_pwm(g_vz, g_dir);

                // run a defined amount of time per tick
                if ((g_timer_ms - last_tick) > MSperTICK)
                {   // update position: 1 tick per xxx ms
                    g_position[g_vz] += g_dir;
                    last_tick = g_timer_ms;
                }

                break;
                      
            /// - HOME command (close direction)
            case state_home:
                nLED = 0;    // home run active
                g_dir = 0;
                if ((0 == g_vz) || (g_vz > NUM_VZ)) // cancel homeing
                {                    
                    g_STATUSflags.home = 0;     // done
                    g_STATUSflags.vz = 0;       // deselect drive
                    main_state = state_idle;
                }
                else if (over_current (g_vz))   // end position reached?
                {
                    g_position[g_vz] = 0;           // set home position
                    g_vbemf_sum[g_vz] = 0;          // set home position
                    main_state = state_idle;
                    g_STATUSflags.home = 0;         // done
                    g_STATUSflags.ref |= (uint8_t) (1 << (g_vz - 1));  // ref set  
                }              
                else    // proceed homeing in close direction
                {
                    g_dir = -1;     // set PWM and outputs for close direction
					set_pwm(g_vz, g_dir);
                }
                
                if ((g_timer_ms - last_tick) > MSperTICK)
                {   // update position: 1 tick per xxx ms:                    
                    if (g_position[g_vz] > 0) g_position[g_vz] -= 1;
                    else g_position[g_vz] = 99;    // rollover                 
                    last_tick = g_timer_ms;                   
                }

                // abort homeing after xx seconds
                if ((g_timer_ms - t_home_ms) > 1000)
                {   // count seconds
                    t_home_ms = g_timer_ms;
                    if ((++t_home_s) > TIMEOUThome) 
                    {   
                        main_state = state_idle;
                        g_STATUSflags.home = 0;     // abort
                    }
                }
                
                break;
                
            /** - IDLE (kind of scheduler: check status bits for pending jobs). \n
             *    + For sanity, the IOC INT is disabled and enabled only during 
             *      MOVE and HOME.
             *    + Measure the motor current in idle mode (PWM is off) 
             *      as a control feature. 
             *    + Check the status flags for incoming requests from ESP and
             *      set main_state and parameters as needed.
             */  
            default:
                nLED = 1;   // 1 = off

                RA5PPS = RA4PPS = 0;        
                RC5PPS = RC4PPS = 0;
                RC3PPS = RC6PPS = 0;
                RC7PPS = RB7PPS = 0;              

                g_vbemf = 0;

                // fill up data logger buffers
                for (; g_ns_bemf < LOGSIZE; ) g_vbemf_log[g_ns_bemf++] = 0;
                for (; g_ns_curr < LOGSIZE; ) g_curr_log[g_ns_curr++] = 0;

                
                /* Read motor current via INA219 Shunt Current Register
                 * (1 LSB = 10μV, Rs = 0,1 Ohm => I / 0.1 mA = Us / 10µV).
                 * Exectime ~171 µs. */
                ina219_reg(1);              // exec time ca. 49 µs (@SCL 400 kHz)
                g_mAx10 = ina219_read();    // exec time ca. 72 µs (@SCL 400 kHz)
                if (g_mAx10 < 0) g_mAx10 = 0;   // offset may cause negative readings

                n_overcurr = 0;             // reset over_current counter

#if (TEST_mAMPS2DAC | TEST_VBEMF2DAC) 
//              DAC1DATL = (uint8_t) (g_mAx10 >> 2);    // monitor mAx10
                DAC1DATL = 0;
#endif                
                // valid valve zone selected?              
                if ((g_vz > 0) && (g_vz <= NUM_VZ))
                {
                    if (g_STATUSflags.home)	// home has prioritiy over move
                    {
                        g_STATUSflags.ref &= ~(uint8_t) (1 << (g_vz - 1));
                        g_ns_bemf = 0;    // reset data logger indices
                        g_ns_curr = 0; 

                        t_home_ms = g_timer_ms; // set start time (for timeout)
                        t_home_s  = 0;

                        main_state = state_home; // prio
                    }
                    
                    else if (g_STATUSflags.move) 
                    {
                        g_ns_bemf = 0;    // reset data logger indices
                        g_ns_curr = 0; 
                        
                        main_state = state_move;
                    }
                }

                if (g_STATUSflags.logdata) 
                {
                    if (ix_logdata < LOGSIZE)
                    {
                        while (!U1ERRIRbits.TXMTIF) ;  // until shift reg. is empty
                        sprintf((char *)g_tx232_buf, "%u,%u,%u\n", ix_logdata,
                            g_vbemf_log[ix_logdata], g_curr_log[ix_logdata]);
                        ix_logdata++;
                        printf((char *)g_tx232_buf);    // send data
                    }
                    else
                    {
                        g_STATUSflags.logdata = 0;  // done
                    }
                }
                
                if (g_STATUSflags.bootload) 
                {   // reprogramming via bootload takes ca. 2:30 minutes
                    while (!U1ERRIRbits.TXMTIF) ;  // until shift reg. is empty
                    RESET();
                }
                                
                last_tick = g_timer_ms;     // reset time reference
                break;                        
        } // switch
            
    } // while()        
    
} // main()



/** @brief Command Interpreter
 *  Commands and Queries:
 *  - Move: vz, setpos, max_mA
 *  - Home: vz, max_mA
 *  - max_mA?	Current Limits
 *  - SetPos?	Set positions
 *  - Status?	Detailed status
 *  - Version?	Version of PIC Firmware
 *  - Bootload! Run bootloader
 */
static 
void cmd_interpreter (void)
{
    char        *p;
    uint8_t     u8;
    unsigned    vz = 0, pos = 0;
    int16_t     mAx10 = 0;
    int8_t      error = 0;
    int16_t     timeout;

/// Commands:
    
    // STATUS
    p = strstr((const char *)g_rx232_buf, "Status?");  // STATUS
    if (p != NULL) 
    {
        sprintf((char *)g_tx232_buf, "Status:%u,%u,%u,%u,%u,0x%04X,0x%08lX\n", 
            g_position[1], g_position[2], g_position[3], g_position[4],
            g_mAx10, g_STATUSflags, g_vbemf_sum[g_vz]);
        goto _done;
    }

    
    // MOVE
    p = strstr((const char *)g_rx232_buf, "Move:");  // MOVE
    if (p != NULL) 
    {
        if (g_STATUSflags.home)
        {
            error = E_HOMEING_ACTIVE;
            goto _done;
        }
        if (sscanf(p+5, "%u,%u,%d\n", &vz, &pos, &mAx10) == 3)
        {   // vz = 0: deselect all, [1..4] selects drive 1 to 4
            if (0 == vz) { g_STATUSflags.move = 0; goto _done; }
            else if (vz > NUM_VZ) { error = E_VZ_RANGE; goto _done; }
            
            g_vz = (uint8_t) vz;  // [1 .. 4] 

            if (pos <= 100) g_setpos[vz] = (uint8_t) pos;  // [0 .. 100]
            else {  error = E_SET_POS_RANGE; goto _done; }

             // [ .1 .. 200.0]
            if ((mAx10 > 0) && (mAx10 <= 2000))  g_mAx10_max[vz] = mAx10;
            else {  error = E_SET_POS_RANGE; goto _done; }
        }
        sprintf((char *)g_tx232_buf, "Move:%u,%u,%d\n", 
                                      vz, g_setpos[vz], g_mAx10_max[vz]);
        
        // check if reference is set
        if (g_STATUSflags.ref & (1 << (vz - 1)))
        {
            g_STATUSflags.vz = (uint8_t) (1 << (vz - 1));   // active drive
            g_STATUSflags.move = 1;              // make move active
        }
        else error = E_NO_REFERENCE;
        
        goto _done;
    }

    // HOME
    p = strstr((const char *)g_rx232_buf, "Home:");  // HOME
    if (p != NULL) 
    {
        if (sscanf(p+5, "%u,%u\n", &vz, &mAx10) == 2)
        {   // vz = 0: deselect all, [1..4] selects drive 1 to 4
            if (0 == vz) { g_STATUSflags.ref = 0; goto _done; }
            else if (vz > NUM_VZ) { error = E_VZ_RANGE; goto _done; }

            g_vz = (uint8_t) vz;  // [1 .. 4]

             // [ 0.1 .. 100.0]
            if ((mAx10 > 0) && (mAx10 <= 1000))  g_mAx10_max[vz] = mAx10;
            else { error = E_SET_POS_RANGE; goto _done; }
        }
        sprintf((char *)g_tx232_buf, "Home:%d,%d\n", vz, g_mAx10_max[vz]);
        
        g_STATUSflags.vz = (uint8_t) (1 << (vz - 1));   // active drive
        g_STATUSflags.home = 1;    // make home active
        
        goto _done;
    }
    
    
    // Firmware Version
    p = strstr((const char *)g_rx232_buf, "Version?");
    if (p != NULL) 
    {
        sprintf((char *)g_tx232_buf, "Version: %s\n", g_version);
        goto _done;
    }

    // Set Positions
    p = strstr((const char *)g_rx232_buf, "SetPos?");  // STATUS
    if (p != NULL) 
    {
        sprintf((char *)g_tx232_buf, "SetPos:%u,%u,%u,%u\n", 
            g_setpos[1], g_setpos[2], g_setpos[3], g_setpos[4]);
        goto _done;
    }    

    // Current Limits
    p = strstr((const char *)g_rx232_buf, "max_mA?");  // STATUS
    if (p != NULL) 
    {
        sprintf((char *)g_tx232_buf, "max_mA:%d,%d,%d,%d\n", 
            g_mAx10_max[1], g_mAx10_max[2], g_mAx10_max[3], g_mAx10_max[4]);
        goto _done;
    }

    // Log data
    p = strstr((const char *)g_rx232_buf, "LogData?");  // LOGDATA
    if (p != NULL) 
    {   // here we can only acknowledge the command:
        ix_logdata = 0;
        sprintf((char *)g_tx232_buf, "LogData:\n");
        g_STATUSflags.logdata = 1;  // transmit logdata to ESP
        goto _done;
    }
    
    // Bootloader
    p = strstr((const char *)g_rx232_buf, "Bootload!");  // UPDATE/BOOTLOAD
    if (p != NULL) 
    {   // write 0xFF into EEPROM[0]
        INTCON0bits.GIEH = 0;     // disable INTs
        NVMADR = EEPROM_BASE + 0x00; // write to EEPROM[0] ...
        NVMDATL = 0xFF;              // .. 0xFF to enable bootloader
        NVMCON1bits.CMD = 0x03;
        NVMLOCK = 0x55;              // unlock EEPROM
        NVMLOCK = 0xAA;
        NVMCON0bits.GO = 1;          // perform write

        for (uint8_t timeout = 0; timeout < 20; ++timeout)
        {
            if (!NVMCON0bits.GO) break;
            else __delay_ms(1);
        }
        NVMCON1bits.CMD = 0;
        
        sprintf((char *)g_tx232_buf, "Bootload!\n");
        g_STATUSflags.bootload = 1;    // reboot after acknowledge
        
        goto _done;
    }        
    
/// Command not found:
    error = E_UNDEF_CMD;
    //goto _done;
    
_done:                
    if (error)
    {
        sprintf((char *)g_tx232_buf, "ERROR %d\n", error);
    }                
    printf((char *)g_tx232_buf);    // send response        
    g_rs232_request = 0;    // ack flag

    // clear uart shift register and RX buffer
    for (uint8_t i = 0; i < sizeof(g_rx232_buf); i++) g_rx232_buf[i] = 0;
    g_rx232_count = 0;
    for (uint8_t c = 0; PIR4bits.U1RXIF; ) c = U1RXB;   // clr RXB (mainly 0x0A)
    PIE4bits.U1RXIE = 1;    // re-enable U1RX interrupts
    
} // cmd_interpreter ()


/** @brief Check for over current (e.g. due to blocked drive)
 *  - Compares actual current g_mAx10 with limit of selected valve zone vz
 *  - On overcurrent, counter n_overcurr gets incremented, else counter is reset
 *  - If counter exceeds 12 (ca. 100 ms), 
 *    - PWM is stopped, g_dir forced to 0
 *    - Error flag OVER_CURR is set
 *  @param  vz: valve zone [0, 1 - 4]
 * @return  0:  no overcurrent, 1: overcurrent detected
 */
static bool over_current (uint8_t vz)
{
    bool result = false;

    if (g_mAx10 > g_mAx10_max[vz])    // if over current
    {
        if (++n_overcurr > 12)        // lasts longer than 100 ms
        {
            set_pwm(vz, 0);           // stop pwm
            g_dir = 0;
            g_ERRORflags.OVER_CURR = 1;
            result = true;
        }
    }
    else n_overcurr = 0;  // reset spike counter

    return (result);
    
} // over_current ()


/** @brief Configures Port Pins and PPS (Peripheral Pin Selects) to output the
 *  PWM signal to the required ports for given valve zone vz and direction dir.
 *  @param  vz:     valve zone [0, 1 - 4]
 *          dir:    direction [-1, 0, +1] (+1 = open, 0 = stop, -1 = close)
 */ 
static void set_pwm (uint8_t vz,    // valve zone [0, 1 - 4]
                     int8_t  dir)   // direction [-1, 0, +1]
{
    // Wait until PWM1 parameter 1 interrupt occurs (H-bridge switched OFF) 
    // to get a complete duty cycle and period on the first PWM output
    PWM1GIRbits.S1P1IF = 0;
    for (uint8_t timout = 0; (!PWM1GIRbits.S1P1IF) && (timout < 200); timout++)
    {
        __delay_us(50);
    }
    
    switch (vz)   // select vz
    {
        case 4:
            if      (+1 == dir) // open
            {   /* - switch PWM @RC3 = IN7 On
                 * - enable IOC @C3 falling edge: read Current
                 * - enable IOC @C3 rising edge:  read Back EMF */
                RC3PPS = 0x0A;      // PWM1S1P1_OUT
                RC6PPS = 0; 

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else if (-1 == dir) // close
            {   /* - switch PWM @RC6 = IN8 On
                 * - enable IOC @RC6 falling edge: read Current
                 * - enable IOC @RC6 rising edge:  read Back EMF */
                RC3PPS = 0;     // map RC3 as port pin (LATxy = 0)
                RC6PPS = 0x0A;  // map RC6 as PWM1S1P1_OUT

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else    // stop
            { 
                RC3PPS = RC6PPS = 0;    // IN7 = IN8 = 0 (NO RUN))
                PWM1GIE = 0;            // Disable parameter interrupts in PWM1
                PIE4bits.PWM1IE = 0;    // disable PWM1_16BIT param interrupts
            }
            break;
            
        case 3:
            if      (+1 == dir) // open
            {   /* - switch PWM @RC7 = IN5 On
                 * - enable IOC @RC7 falling edge: read Current
                 * - enable IOC @RC7 rising edge:  read Back EMF */
                RC7PPS = 0x0A;  // PWM1S1P1_OUT
                RB7PPS = 0; 

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else if (-1 == dir) // close
            {   /* - switch PWM @RB7 = IN6 On
                 * - enable IOC @RB7 falling edge: read Current
                 * - enable IOC @RB7 rising edge:  read Back EMF */
                RC7PPS = 0;     // map RC7 as port pin (LATxy = 0)
                RB7PPS = 0x0A;  // map RB7 as PWM1S1P1_OUT

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else    // stop
            { 
                RC7PPS = RB7PPS = 0;    // IN5 = IN6 = 0 (NO RUN))
                PWM1GIE = 0;            // Disable parameter interrupts in PWM1
                PIE4bits.PWM1IE = 0;    // disable PWM1_16BIT param interrupts
            }
            break;
            
        case 2:
            if      (+1 == dir) // open
            {   /* - switch PWM @RC4 = IN3 On
                 * - enable IOC @RC4 falling edge: read Current
                 * - enable IOC @RC4 rising edge:  read Back EMF */
                RC4PPS = 0x0A;  // PWM1S1P1_OUT
                RC5PPS = 0; 

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else if (-1 == dir) // close
            {   /* - switch PWM @RC5 = IN4 On
                 * - enable IOC @RC5 falling edge: read Current
                 * - enable IOC @RC5 rising edge:  read Back EMF */
                RC4PPS = 0;     // map RC4 as port pin (LATxy = 0)
                RC5PPS = 0x0A;  // map RC5 as PWM1S1P1_OUT

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else    // stop
            { 
                RC4PPS = RC5PPS = 0;    // IN3 = IN4 = 0 (NO RUN))
                PWM1GIE = 0;            // Disable parameter interrupts in PWM1
                PIE4bits.PWM1IE = 0;    // disable PWM1_16BIT param interrupts
            }
            break;
            
        case 1:
            if      (+1 == dir) // open
            {   /* - switch PWM @RA4 = IN1 On
                 * - enable IOC @RA4 falling edge: read Current
                 * - enable IOC @RA4 rising edge:  read Back EMF */
                RA4PPS = 0x0A;  // PWM1S1P1_OUT
                RA5PPS = 0; 

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else if (-1 == dir) // close
            {   /* - switch PWM @RA5 = IN2 On
                 * - enable IOC @RA5 falling edge: read Current
                 * - enable IOC @RA5 rising edge:  read Back EMF */
                RA4PPS = 0;     // map RA4 as port pin (LATxy = 0)
                RA5PPS = 0x0A;  // map RA5 as PWM1S1P1_OUT

                PWM1GIR = 0;            // clear PWM1 interrupts flags
                PWM1GIEbits.S1P1IE = 1; // enable PWM1 Param1 int (right edge)
                PWM1GIEbits.S1P2IE = 1; // enable PWM1 Param2 int (right edge)
                PIE4bits.PWM1IE = 1;    // enable PWM1_16BIT param interrupts
            }
            else    // stop
            { 
                RA4PPS = RA5PPS = 0;    // IN1 = IN2 = 0 (NO RUN))
                PWM1GIE = 0;            // Disable parameter interrupts in PWM1
                PIE4bits.PWM1IE = 0;    // disable PWM1_16BIT param interrupts
                NOP();
            }
            break;
            
        case 0:     // off
        default:
            
            break;
    } // switch
    
} // set_pwm()
        
        
/**
 End of File
*/